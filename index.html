<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <!-- Support dark/light mode and theme colors -->
    <meta name="color-scheme" content="light dark">
    <meta name="theme-color" content="#0078D4" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#0078D4" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#ffffff">
    <title>Fofr Pedro 3D</title>
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0b1220">
    <meta name="description" content="Fofr Pedro – satirická 3D endless runner hra z pražského podsvětí.">
    <!-- Link to the external web app manifest. This prevents the inlined PWA setup from injecting
         a data URI manifest and allows us to provide a standalone manifest.json file. -->
    <link rel="manifest" href="manifest.json">

    <style>
        :root {
            --bg-color: #0b1220;
            --primary-accent: #7dd3fc; /* Tlumenější modrá */
            --secondary-accent: #a78bfa; /* Tlumenější fialová */
            --text-color: #e5e7eb;
            --glass-bg: rgba(20, 30, 50, 0.6);
            --glass-border: rgba(229, 231, 235, 0.2);
            --font-header: 'Orbitron', sans-serif;
            --font-body: 'Share Tech Mono', monospace;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --tap-target-size: 44px;
        }

        /* Load generic system fonts instead of remote webfonts. These generic
           families are widely available and do not require network access. */
        @font-face {
            font-family: 'Orbitron';
            src: local('Arial');
            font-weight: 700;
        }

        @font-face {
            font-family: 'Share Tech Mono';
            src: local('Courier New');
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-body);
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents browser gestures */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .glass-panel {
            background: var(--glass-bg);
            /* Vendor-prefixed backdrop filter should come before the standard property */
            -webkit-backdrop-filter: blur(12px);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            pointer-events: all;
            animation: fadeIn 0.5s ease-out forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(125, 211, 252, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(125, 211, 252, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 15px rgba(125, 211, 252, 0.5); }
        }

        /* --- Screens (Start/Game Over) --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.5);
            z-index: 100;
            padding: 20px;
        }

        .screen .glass-panel {
            width: 100%;
            max-width: 380px;
            padding: 30px;
            text-align: center;
        }

        .screen h1 {
            font-family: var(--font-header);
            font-size: clamp(2.5rem, 8vw, 3.5rem);
            color: var(--primary-accent);
            text-shadow: 0 0 10px var(--primary-accent), 0 0 20px var(--primary-accent);
            margin-bottom: 20px;
        }

        .screen p {
            margin-bottom: 25px;
            line-height: 1.6;
            opacity: 0.9;
        }
        
        .disclaimer { font-size: 0.8em; opacity: 0.6; font-style: italic; }

        .button {
            background: linear-gradient(45deg, var(--primary-accent), var(--secondary-accent));
            border: none; border-radius: 12px; color: var(--bg-color);
            font-weight: bold; padding: 15px 30px;
            font-family: var(--font-header); font-size: 1.2em; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.5);
            width: 100%; margin-top: 10px;
        }
        .button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(125, 211, 252, 0.7);
        }
        #install-button {
            background: transparent; border: 2px solid var(--primary-accent);
            color: var(--primary-accent); animation: pulse 2s infinite;
        }

        /* --- HUD --- */
        #hud {
            width: 100%; padding: var(--safe-area-top) 20px 0; display: grid;
            grid-template-columns: 1fr auto 1fr; align-items: flex-start;
        }
        .hud-item { font-family: var(--font-header); font-size: 2em; text-shadow: 0 0 5px var(--primary-accent); }
        #speed { text-align: right; padding-right: 20px; }
        #score { padding-left: 20px; }
        #center-hud { display: flex; flex-direction: column; align-items: center; gap: 8px; }
        #powerup-display { display: flex; align-items: center; gap: 5px; background: var(--glass-bg); border-radius: 10px; padding: 5px 10px; height: 40px; min-width: 80px; justify-content: center; }
        #powerup-icon { font-size: 1.5em; }
        #powerup-timer { font-family: var(--font-body); font-size: 1em; }
        #flip-combo-display { font-family: var(--font-body); font-size: 1em; color: var(--secondary-accent); text-shadow: 0 0 5px var(--secondary-accent); opacity: 0; transition: opacity 0.3s; transform: translateY(10px); }
        #flip-combo-display.visible { opacity: 1; transform: translateY(0); }
        #lives-display { display: flex; gap: 5px; color: var(--secondary-accent); justify-content: flex-end; }


        /* --- Bottom Panel & Tabs --- */
        #bottom-panel { width: 100%; padding: 20px 20px calc(20px + var(--safe-area-bottom)); }
        #bottom-panel-content { padding: 20px; padding-bottom: 70px; text-align: center; position: relative; }
        #pause-button { position: absolute; top: -22px; left: 50%; transform: translateX(-50%); width: var(--tap-target-size); height: var(--tap-target-size); border-radius: 50%; border: 1px solid var(--glass-border); background: var(--glass-bg); color: var(--text-color); font-size: 1.5em; display: flex; justify-content: center; align-items: center; cursor: pointer; pointer-events: all; }
        .panel-section { display: none; flex-direction: column; gap: 15px; }
        .panel-section.active { display: flex; }
        .tabs { position: absolute; bottom: 15px; left: 15px; right: 15px; display: flex; justify-content: center; gap: 10px; }
        .tab-button { background: transparent; border: 1px solid var(--glass-border); color: var(--text-color); padding: 8px 15px; border-radius: 10px; flex-grow: 1; font-family: var(--font-body); cursor: pointer; }
        .tab-button.active { background: var(--primary-accent); color: var(--bg-color); border-color: var(--primary-accent); }
        
        /* Specific panel styles */
        .leaderboard-list { list-style: none; padding: 0; text-align: left; max-height: 150px; overflow-y: auto; }
        .leaderboard-list li { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--glass-border); }
        .leaderboard-list li:last-child { border-bottom: none; }
        .settings-grid { display: grid; grid-template-columns: 1fr auto; gap: 15px; text-align: left; align-items: center; }
        .settings-grid input[type=checkbox] { width: 20px; height: 20px; accent-color: var(--primary-accent); }
        #skins-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; }
        .skin-button { width: 60px; height: 60px; border-radius: 10px; border: 2px solid var(--glass-border); background: var(--glass-bg); position: relative; cursor: pointer; }
        .skin-button.active { border-color: var(--primary-accent); box-shadow: 0 0 10px var(--primary-accent); }
        .skin-button.locked::after { content: '🔒'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2em; color: rgba(255,255,255,0.5); text-shadow: none; pointer-events: none; }
        .skin-color-preview { width: 100%; height: 100%; border-radius: 8px; }

        /* --- Toasts --- */
        #toast-container { position: absolute; top: 25%; left: 0; width: 100%; display: flex; flex-direction: column; align-items: center; gap: 10px; z-index: 200; }
        .toast { padding: 10px 20px; opacity: 0; transform: translateY(20px); transition: opacity 0.5s, transform 0.5s; max-width: 80%; }
        .toast.show { opacity: 1; transform: translateY(0); }
        
        .hidden { display: none !important; }

        /* --- Debug Overlay --- */
        #debug-overlay { position: absolute; top: calc(var(--safe-area-top) + 80px); left: 10px; background: rgba(0,0,0,0.7); padding: 5px; border-radius: 5px; font-size: 0.8em; z-index: 999; pointer-events: none; white-space: pre; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="start-screen" class="screen">
            <div class="glass-panel">
                <h1>Fofr Pedro</h1>
                <p>Uteč fízlům v satirickém 3D běhu Prahou. Sbírej "šlehy", vyhýbej se průšvihům a ukaž, kdo je král Žižkova.</p>
                <p class="disclaimer">16+ | Hra obsahuje černý humor a satirický obsah. Neglorifikuje nelegální činnosti.</p>
                <button id="start-button" class="button">Začít Fofr</button>
                <button id="install-button" class="button hidden">Instalovat hru</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <div class="glass-panel">
                <h1>Konec Hry</h1>
                <p>Lapen! Skóre: <span id="final-score">0</span></p>
                <input type="text" id="player-name-input" placeholder="Zadej jméno pro žebříček" style="width:100%; padding:10px; border-radius:8px; border:1px solid var(--glass-border); background:var(--glass-bg); color:white; margin-bottom: 10px; text-align: center; font-family: var(--font-body);">
                <button id="restart-button" class="button">Další pokus</button>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div id="score" class="hud-item">0</div>
            <div id="center-hud">
                <div id="powerup-display">
                    <span id="powerup-icon"></span>
                    <span id="powerup-timer"></span>
                </div>
                <div id="flip-combo-display"></div>
            </div>
            <div id="lives-display" class="hud-item"></div>
        </div>
        
        <!-- Bottom Panel -->
        <div id="bottom-panel">
             <button id="pause-button">❚❚</button>
            <div id="bottom-panel-content" class="glass-panel hidden">
                <!-- Panel Sections -->
                <div class="panel-section active" id="settings-section">
                    <h3>Nastavení</h3>
                    <div class="settings-grid">
                        <label for="acrobatic-jumps-toggle">Akrobatické skoky</label> <input type="checkbox" id="acrobatic-jumps-toggle">
                        <label for="haptics-toggle">Vibrace</label> <input type="checkbox" id="haptics-toggle">
                        <label for="sound-toggle">Zvuk</label> <input type="checkbox" id="sound-toggle">
                        <label for="reduced-motion-toggle">Omezený pohyb</label> <input type="checkbox" id="reduced-motion-toggle">
                    </div>
                </div>
                <div class="panel-section" id="leaderboard-section"><h3>TOP 5 Běžců</h3><ul id="leaderboard-list"></ul></div>
                <div class="panel-section" id="skins-section"><h3>Skiny</h3><div id="skins-grid"></div></div>
                <div class="panel-section" id="data-section">
                    <h3>Data</h3>
                    <button id="export-button" class="button" style="font-size: 1em; padding: 10px;">Exportovat JSON</button>
                    <input type="file" id="import-input" class="hidden" accept=".json">
                    <button onclick="document.getElementById('import-input').click()" class="button" style="font-size: 1em; padding: 10px;">Importovat JSON</button>
                </div>

                <!-- Tabs -->
                <div class="tabs">
                    <button class="tab-button active" data-target="settings-section">⚙️</button>
                    <button class="tab-button" data-target="leaderboard-section">🏆</button>
                    <button class="tab-button" data-target="skins-section">👕</button>
                    <button class="tab-button" data-target="data-section">💾</button>
                </div>
            </div>
        </div>

        <!-- Toasts -->
        <div id="toast-container"></div>
    </div>
    
    <div id="debug-overlay" class="hidden"></div>
    
    <script type="importmap">
    {
        "imports": {
            /* Use locally stored modules instead of downloading from a CDN. The file
               'three.module.js' is stored next to this HTML, and the GLTFLoader
               module is provided in 'GLTFLoader.js'. Mapping these paths here
               allows the browser's module loader to resolve imports correctly
               without an internet connection. */
            "three": "./three.module.js",
            "three/addons/loaders/GLTFLoader.js": "./GLTFLoader.js"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CORE GAME SETUP ---
        const gameContainer = document.getElementById('game-container');
        let scene, camera, renderer, clock, floor;
        let gameActive = false, isPaused = false;
        const state = {
            speed: 0, baseSpeed: 15, maxSpeed: 50, score: 0, distance: 0, lives: 3,
            powerUp: { type: null, timer: 0, originalSpeed: 0 },
        };

        // --- VISUAL & AUDIO EFFECTS ---
        let particleSystem;
        let cameraShake = { duration: 0, intensity: 0 };
        let audioListener;
        let musicFadeOut = false;
        const audio = { sounds: {}, music: null };
        // Define audio assets. When running offline, it's not possible to
        // download sound effects from CDNs, so leave this object empty. The
        // game will still run, but without audio. To add audio in the
        // future, place OGG files in the project directory and map them here.
        const audioAssets = {};


        // --- DOM ELEMENTS ---
        const ui = {
            startScreen: document.getElementById('start-screen'),
            installButton: document.getElementById('install-button'),
            gameOverScreen: document.getElementById('game-over-screen'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            hud: document.getElementById('hud'),
            score: document.getElementById('score'),
            livesDisplay: document.getElementById('lives-display'),
            finalScore: document.getElementById('final-score'),
            playerNameInput: document.getElementById('player-name-input'),
            bottomPanel: document.getElementById('bottom-panel'),
            bottomPanelContent: document.getElementById('bottom-panel-content'),
            pauseButton: document.getElementById('pause-button'),
            toastContainer: document.getElementById('toast-container'),
            debugOverlay: document.getElementById('debug-overlay'),
            powerupIcon: document.getElementById('powerup-icon'),
            powerupTimer: document.getElementById('powerup-timer'),
            flipComboDisplay: document.getElementById('flip-combo-display'),
            acrobaticJumpsToggle: document.getElementById('acrobatic-jumps-toggle'),
            hapticsToggle: document.getElementById('haptics-toggle'),
            reducedMotionToggle: document.getElementById('reduced-motion-toggle'),
            soundToggle: document.getElementById('sound-toggle'),
            skinsGrid: document.getElementById('skins-grid'),
            leaderboardList: document.getElementById('leaderboard-list'),
            importInput: document.getElementById('import-input'),
            exportButton: document.getElementById('export-button'),
        };

        // --- PLAYER & OBJECTS ---
        // Use a locally stored hero model instead of a remote placeholder. The file
        // 'kenney3d_char_pedro.glb' is placed next to this HTML file in the project.
        const HERO_MODEL_URL = 'kenney3d_char_pedro.glb';
        // Paths for additional 3D models used as obstacles. These will be preloaded at
        // startup so that spawning obstacles does not incur network latency.
        const MODEL_PATHS = {
            police: 'kenney3d_char_police.glb',
            car01: 'kenney3d_prop_car01.glb',
            car02: 'kenney3d_prop_car02.glb',
            scooter: 'kenney3d_prop_scooter.glb'
        };
        // Storage for loaded GLTF scenes. Each key in MODEL_PATHS will be loaded into this
        // object before the game starts.
        const loadedModels = {};

        /**
         * Preload all GLTF models defined in MODEL_PATHS. Returns a promise that
         * resolves once all models have either loaded or gracefully failed. Failed
         * loads are logged but will not break game initialization.
         */
        function loadModels() {
            const loader = new GLTFLoader();
            const entries = Object.entries(MODEL_PATHS);
            return Promise.all(entries.map(([key, path]) => {
                return new Promise((resolve) => {
                    loader.load(path, (gltf) => {
                        loadedModels[key] = gltf.scene;
                        resolve();
                    }, undefined, (error) => {
                        console.warn('Failed to load model:', path, error);
                        loadedModels[key] = null;
                        resolve();
                    });
                });
            }));
        }

        /**
         * Clone a preloaded model by key. The returned object has shadows enabled on
         * all mesh children. If the model is not loaded or null, a simple box mesh
         * is returned to avoid runtime errors.
         * @param {string} key The key of the model in MODEL_PATHS and loadedModels
         * @returns {THREE.Object3D}
         */
        function preparedClone(key) {
            const original = loadedModels[key];
            if (!original) {
                // fallback object for missing models
                const box = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0xff00ff }));
                box.castShadow = true;
                box.receiveShadow = true;
                return box;
            }
            const clone = original.clone(true);
            clone.traverse(node => {
                if (node.isMesh) {
                    node.castShadow = true;
                    node.receiveShadow = true;
                }
            });
            return clone;
        }
        const player = {
            mesh: null, collider: null, state: 'running', lane: 0, velocityY: 0, gravity: -60,
            jumpForce: 25, frontFlipForce: 30, targetX: 0, slideTimer: 0, flipCooldown: 0,
            coyoteTimer: 0, lastFlipTime: 0, isInvincible: false, modelReady: false, aura: null,
            mixer: null, animations: {}
        };
        const LANE_WIDTH = 3.5;
        const activeCollectibles = [];
        const activeObstacles = [];
        const pools = { obstacles: new Map(), collectibles: new Map() };
        let floorSegments = [];

        // --- SETTINGS & DATA ---
        let settings = {
            acrobaticJumps: true, haptics: true, reducedMotion: false, audio: true,
            leaderboard: [],
            skins: { unlocked: ['default'], current: 'default' }
        };
        const SKINS = {
            default: { color: 0x7dd3fc, name: 'Pedro' },
            pro: { color: 0xffff00, name: 'Profi', unlock: 5000 },
            veteran: { color: 0x00ff00, name: 'Veterán', unlock: 20000 },
        };
        
        const isDebug = new URLSearchParams(window.location.search).has('debug');
        let deferredInstallPrompt = null;
        const SAVE_KEY = 'fofrPedroSaveData_v1';

        // --- INITIALIZATION ---
        function init() {
            // setupPWA();
            // PWA initialization is handled via an external manifest and service worker.
            loadState();
            // Preload all external GLB models before continuing with the rest of
            // initialization. This ensures obstacles and hero assets are ready.
            loadModels().then(() => {
                setupScene();
                setupAudio();
                setupParticles();
                setupPlayer();
                setupWorld();
                setupControls();
                setupUI();

                if (isDebug) ui.debugOverlay.classList.remove('hidden');

                clock = new THREE.Clock();
                animate();
            });
        }
        
        // --- PWA & SERVICE WORKER ---
        function setupPWA() {
            const manifest = {
                "name": "Fofr Pedro 3D",
                "short_name": "FofrPedro",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#0b1220",
                "theme_color": "#0b1220",
                "description": "Satirická 3D endless runner hra z pražského podsvětí.",
                // Use locally stored icons instead of placeholder services. The files
                // 'icon-192.png' and 'icon-512.png' are included in the project root.
                "icons": [
                    { "src": "icon-192.png", "type": "image/png", "sizes": "192x192", "purpose": "any maskable" },
                    { "src": "icon-512.png", "type": "image/png", "sizes": "512x512", "purpose": "any maskable" }
                ]
            };
            const manifestURL = 'data:application/json;charset=utf-8,' + encodeURIComponent(JSON.stringify(manifest));
            document.head.insertAdjacentHTML('beforeend', `<link rel="manifest" href="${manifestURL}">`);

            if ('serviceWorker' in navigator && !window.location.href.startsWith('blob:')) {
                const swCode = `
                    const CACHE_NAME = 'fofr-pedro-cache-v1';
                    const urlsToCache = [
                        '/',
                        'https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js',
                        'https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/loaders/GLTFLoader.js',
                        'https://fonts.gstatic.com/s/orbitron/v25/yMJRMIlzdpvBhQQL_Qq7dy0.woff2',
                        'https://fonts.gstatic.com/s/sharetechmono/v15/Jwc5WYQjV4_es_AkdtFHmmAta04.woff2',
                        ...Object.values(${JSON.stringify(audioAssets)})
                    ];
                    self.addEventListener('install', e => {
                        console.log('[SW] Instalace...');
                        e.waitUntil(caches.open(CACHE_NAME).then(c => c.addAll(urlsToCache).then(() => self.skipWaiting())));
                    });
                    self.addEventListener('activate', e => {
                        console.log('[SW] Aktivace...');
                        e.waitUntil(caches.keys().then(keys => Promise.all(
                            keys.map(key => key !== CACHE_NAME ? caches.delete(key) : null)
                        )).then(() => self.clients.claim()));
                    });
                    self.addEventListener('fetch', e => {
                        if (e.request.method !== 'GET') return;
                        e.respondWith(caches.match(e.request).then(response => {
                             const fetchPromise = fetch(e.request).then(networkResponse => {
                                if (networkResponse && networkResponse.status === 200) {
                                    caches.open(CACHE_NAME).then(cache => cache.put(e.request, networkResponse.clone()));
                                }
                                return networkResponse;
                            }).catch(() => {}); // Handle fetch errors for offline
                            return response || fetchPromise;
                        }));
                    });
                `;
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                window.addEventListener('load', () => {
                     navigator.serviceWorker.register(swURL).then(reg => console.log('[SW] Registrace úspěšná:', reg.scope)).catch(err => console.error('[SW] Registrace selhala:', err));
                });
            }

            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredInstallPrompt = e;
                ui.installButton.classList.remove('hidden');
            });
            ui.installButton.addEventListener('click', async () => {
                if (deferredInstallPrompt) {
                    deferredInstallPrompt.prompt();
                    await deferredInstallPrompt.userChoice;
                    deferredInstallPrompt = null;
                    ui.installButton.classList.add('hidden');
                }
            });
        }

        // --- 3D SETUP ---
        function setupScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0b1220, 20, 80);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 6, 12);
            camera.rotation.x = -0.3;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x0b1220, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.appendChild(renderer.domElement);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 10;
            dirLight.shadow.camera.bottom = -10;
            dirLight.shadow.camera.left = -10;
            dirLight.shadow.camera.right = 10;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);
        }
        function setupPlayer() {
            // Fallback capsule
            const fallbackGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 16);
            const fallbackMat = new THREE.MeshStandardMaterial({ color: SKINS.default.color });
            player.mesh = new THREE.Mesh(fallbackGeo, fallbackMat);
            player.mesh.castShadow = true;
            player.mesh.position.y = 1.5;
            scene.add(player.mesh);
            
            // Invincibility Aura
            const auraTexture = new THREE.CanvasTexture(createGlowTexture());
            const auraMaterial = new THREE.SpriteMaterial({ map: auraTexture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.8 });
            player.aura = new THREE.Sprite(auraMaterial);
            player.aura.scale.set(4, 4, 4);
            player.aura.position.y = 1.0;
            player.aura.visible = false;
            player.mesh.add(player.aura);

            applySkin(settings.skins.current);
            
            // GLTF Loader
            const loader = new GLTFLoader();
            loader.load(HERO_MODEL_URL, (gltf) => {
                console.log("Hrdina načten!", gltf);
                const hero = gltf.scene;
                
                hero.scale.set(1.0, 1.0, 1.0);
                hero.position.y = 0;
                hero.traverse(child => { 
                    if(child.isMesh) { 
                        child.castShadow = true; 
                        child.receiveShadow = true; 
                    }
                });
                
                player.aura.position.y = 1.0; // Center aura on the robot
                hero.add(player.aura);

                scene.remove(player.mesh); 
                player.mesh = hero;
                player.modelReady = true;

                // --- Animation Setup ---
                player.mixer = new THREE.AnimationMixer(hero);
                const clips = gltf.animations;
                const animMap = {
                    running: 'running',
                    jumping: 'jump',
                    sliding: 'death' // Using 'death' animation for slide
                };

                Object.entries(animMap).forEach(([key, clipName]) => {
                    const clip = THREE.AnimationClip.findByName(clips, clipName);
                    if (clip) {
                        const action = player.mixer.clipAction(clip);
                        player.animations[key] = action;
                        if (key !== 'running') {
                            action.setLoop(THREE.LoopOnce);
                            action.clampWhenFinished = true;
                        }
                    }
                });

                if (player.animations.running) {
                    player.animations.running.play();
                }
                // ----------------------

                applySkin(settings.skins.current);

            }, undefined, (error) => {
                console.warn("Nepodařilo se načíst model hrdiny, používá se záložní kapsle.", error);
            });

            player.collider = new THREE.Box3();
        }
        function setupWorld() { 
            const segmentLength = 200;
            const segmentGeo = new THREE.PlaneGeometry(LANE_WIDTH * 3, segmentLength);
            const segmentMat = new THREE.MeshStandardMaterial({ color: 0x222233 });

            for (let i = 0; i < 2; i++) {
                const segment = new THREE.Mesh(segmentGeo, segmentMat);
                segment.rotation.x = -Math.PI / 2;
                segment.receiveShadow = true;
                segment.position.z = -i * segmentLength + segmentLength / 2 - 50;
                scene.add(segment);
                floorSegments.push(segment);
            }
        }
        
        // --- AUDIO & VISUAL EFFECTS ---
        function setupAudio() {
            audioListener = new THREE.AudioListener();
            camera.add(audioListener);
            const audioLoader = new THREE.AudioLoader();
            const soundPromises = [];

            Object.entries(audioAssets).forEach(([name, url]) => {
                const promise = new Promise((resolve, reject) => {
                    audioLoader.load(url, (buffer) => {
                        if (name === 'music') {
                            audio.music = new THREE.Audio(audioListener);
                            audio.music.setBuffer(buffer);
                            audio.music.setLoop(true);
                            audio.music.setVolume(0.3);
                        } else {
                            audio.sounds[name] = buffer;
                        }
                        resolve();
                    }, undefined, reject);
                });
                soundPromises.push(promise);
            });

            Promise.all(soundPromises)
                .then(() => console.log("Všechny zvuky úspěšně načteny."))
                .catch(err => console.error("Chyba při načítání zvuků:", err));
        }

        function playSound(name, volume = 0.5) {
            if (!settings.audio || !audio.sounds[name] || !audioListener) return;
            const sound = new THREE.Audio(audioListener);
            sound.setBuffer(audio.sounds[name]);
            sound.setVolume(volume);
            sound.play();
        }

        function setupParticles() {
            const MAX_PARTICLES = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(MAX_PARTICLES * 3);
            const colors = new Float32Array(MAX_PARTICLES * 3);
            const alphas = new Float32Array(MAX_PARTICLES);

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
            });

            const points = new THREE.Points(geometry, material);
            points.frustumCulled = false;
            scene.add(points);

            const pool = [];
            for (let i = 0; i < MAX_PARTICLES; i++) {
                pool.push({
                    active: false,
                    position: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    lifetime: 0,
                    alpha: 0,
                    color: new THREE.Color(),
                });
            }

            particleSystem = { mesh: points, pool, current: 0 };
        }
        
        function updateParticles(delta) {
            const { mesh, pool } = particleSystem;
            const positions = mesh.geometry.attributes.position.array;
            const colors = mesh.geometry.attributes.color.array;
            const alphas = mesh.geometry.attributes.alpha.array;
            
            let activeCount = 0;
            for (let i = 0; i < pool.length; i++) {
                const p = pool[i];
                if (p.active) {
                    p.position.addScaledVector(p.velocity, delta);
                    p.velocity.y -= 5 * delta; // gravity
                    p.lifetime -= delta;
                    p.alpha -= 1.5 * delta;

                    if (p.lifetime <= 0 || p.alpha <= 0) {
                        p.active = false;
                        continue;
                    }
                    
                    p.position.toArray(positions, activeCount * 3);
                    p.color.toArray(colors, activeCount * 3);
                    alphas[activeCount] = p.alpha;
                    
                    activeCount++;
                }
            }
            
            // Swap inactive particles to the end for next time
            for (let i = activeCount; i < pool.length; i++) {
                 if (pool[i].active) {
                    const temp = pool[i];
                    pool[i] = pool[activeCount];
                    pool[activeCount] = temp;
                    
                    temp.position.toArray(positions, activeCount * 3);
                    temp.color.toArray(colors, activeCount * 3);
                    alphas[activeCount] = temp.alpha;
                    
                    activeCount++;
                }
            }

            mesh.geometry.setDrawRange(0, activeCount);
            mesh.geometry.attributes.position.needsUpdate = true;
            mesh.geometry.attributes.color.needsUpdate = true;
            mesh.geometry.attributes.alpha.needsUpdate = true;
        }

        function triggerParticles(position, count, color, speed, baseZVelocity = 0) {
            for (let i = 0; i < count; i++) {
                let p = particleSystem.pool[particleSystem.current];
                
                p.active = true;
                p.lifetime = 0.5 + Math.random() * 0.5;
                p.position.copy(position);
                p.velocity.set(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.2) * speed,
                    (Math.random() - 0.5) * speed + baseZVelocity
                );
                p.color.copy(color);
                p.alpha = 1.0;
                
                particleSystem.current = (particleSystem.current + 1) % particleSystem.pool.length;
            }
        }
        
        function triggerScreenShake(intensity, duration) {
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
        }
        
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 0, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return canvas;
        }

        // --- GAME FLOW ---
        function startGame() {
            Object.assign(state, { speed: state.baseSpeed, score: 0, distance: 0, lives: 3 });
            state.powerUp = { type: null, timer: 0 };
            Object.assign(player, { lane: 0, targetX: 0, state: 'running', lastFlipTime: 0, isInvincible: false });
            player.mesh.position.set(0, player.modelReady ? 0 : 1.5, 0);
            player.mesh.rotation.set(0,0,0);

            [...activeObstacles, ...activeCollectibles].forEach(o => o.visible = false);
            activeObstacles.length = 0;
            activeCollectibles.length = 0;
            
            ui.startScreen.classList.add('hidden');
            ui.gameOverScreen.classList.add('hidden');
            ui.hud.classList.remove('hidden');
            ui.bottomPanel.classList.remove('hidden');
            
            updateLivesUI();
            
            isPaused = false;
            gameActive = true;
            ui.pauseButton.textContent = '❚❚';

            musicFadeOut = false;
            if (settings.audio && audio.music && !audio.music.isPlaying) {
                audio.music.setVolume(0.3);
                audio.music.play();
            }
        }
        function gameOver() {
            gameActive = false;
            handleVibrate([100, 50, 100]);
            playSound('hit', 0.6);
            musicFadeOut = true;
            ui.gameOverScreen.classList.remove('hidden');
            ui.finalScore.textContent = Math.floor(state.score);
            
            ui.playerNameInput.addEventListener('change', () => {
                updateLeaderboard(ui.playerNameInput.value, Math.floor(state.score));
            });
        }
        
        function togglePause() {
            isPaused = !isPaused;
            ui.bottomPanelContent.classList.toggle('hidden');
            ui.pauseButton.textContent = isPaused ? '▶' : '❚❚';
            if(isPaused) {
                if (audio.music && audio.music.isPlaying) audio.music.pause();
                renderLeaderboard();
                renderSkins();
            } else {
                if (settings.audio && audio.music && !audio.music.isPlaying) audio.music.play();
            }
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.05);
            
            if (!gameActive) {
                // Animate background elements on start screen if any
            } else if (!isPaused) {
                updateWorld(delta);
                updatePlayer(delta);
                updateParticles(delta);
                handleCollisions();
                updateHUD();
            }

            if (musicFadeOut && audio.music && audio.music.isPlaying) {
                const newVolume = Math.max(0, audio.music.getVolume() - delta * 0.5); // Fade over 2 seconds
                audio.music.setVolume(newVolume);
                if (newVolume === 0) {
                    audio.music.stop();
                    musicFadeOut = false;
                }
            }

            // Screen Shake
            const BASE_CAMERA_POS = new THREE.Vector3(0, 6, 12);
            if (cameraShake.duration > 0 && !settings.reducedMotion) {
                cameraShake.duration -= delta;
                const shake = cameraShake.intensity * (cameraShake.duration / 0.4); 
                camera.position.x = BASE_CAMERA_POS.x + (Math.random() - 0.5) * shake;
                camera.position.y = BASE_CAMERA_POS.y + (Math.random() - 0.5) * shake;
            } else {
                cameraShake.duration = 0;
                if (camera.position.x !== BASE_CAMERA_POS.x || camera.position.y !== BASE_CAMERA_POS.y) {
                    camera.position.lerp(BASE_CAMERA_POS, 0.2);
                }
            }

            if (isDebug) updateDebugOverlay(delta);
            renderer.render(scene, camera);
        }

        function updateWorld(delta) {
            state.distance += state.speed * delta;
            state.score += state.speed * delta * 0.5;
            state.speed = Math.min(state.maxSpeed, state.baseSpeed + state.distance / 200);

            [...activeObstacles, ...activeCollectibles].forEach(o => {
                if(o.visible) {
                    o.position.z += state.speed * delta;
                    if(o.userData.type === 'invincibility') o.rotation.y += delta;
                    if (o.position.z > camera.position.z + 10) o.visible = false;
                }
            });

            floorSegments.forEach(segment => {
                segment.position.z += state.speed * delta;
                if (segment.position.z > 200) {
                    segment.position.z -= 400;
                }
            });
             
            if (Math.random() < 0.05) spawnObject();
        }
        
        function updatePlayer(delta) {
            if (player.mixer) {
                player.mixer.update(delta);
            }
            const groundY = player.modelReady ? 0 : 1.5;
            player.mesh.position.x = THREE.MathUtils.lerp(player.mesh.position.x, player.targetX, 0.2);
            const onGround = player.mesh.position.y <= groundY;
            
            if (onGround) {
                player.coyoteTimer = 0.12;
                if(player.state !== 'sliding') player.state = 'running';
            } else {
                player.coyoteTimer -= delta;
            }
            if (!onGround) {
                player.velocityY += player.gravity * delta;
                player.mesh.position.y += player.velocityY * delta;
            }
            if (player.mesh.position.y < groundY) {
                player.mesh.position.y = groundY;
                player.velocityY = 0;
                if (player.state === 'flipping') {
                    player.mesh.rotation.x = 0;
                    player.flipCooldown = 0.5;
                    addFlipScore();
                }
                if (player.state !== 'sliding') player.state = 'running';
            }
            if(player.state === 'flipping' && !settings.reducedMotion) {
                player.mesh.rotation.x += delta * 15;
            }
            if (player.flipCooldown > 0) player.flipCooldown -= delta;
            if (player.slideTimer > 0) player.slideTimer -= delta;
            if (player.state === 'sliding' && player.slideTimer <= 0) {
                 player.state = 'running';
                 player.mesh.position.y = groundY;
            }
            // Powerup Timer
            if (state.powerUp.timer > 0) {
                state.powerUp.timer -= delta;
                if (state.powerUp.timer <= 0) deactivatePowerUp();
            }

            // Speed trail particles
            const speedThreshold = state.baseSpeed * 1.25;
            if (gameActive && !isPaused && state.speed > speedThreshold && Math.random() < 0.7) {
                const trailPos = player.mesh.position.clone();
                trailPos.y += 1.0;
                const trailColor = new THREE.Color(0xa78bfa);
                triggerParticles(trailPos, 1, trailColor, 0.2, -state.speed * 0.1);
            }
        }
        
        // --- OBJECT SPAWNING ---
        // Define obstacles using the preloaded models. Each obstacle has a factory
        // that returns a cloned Object3D. The 'y' property in props controls the
        // vertical offset when the object is spawned to ensure it sits properly
        // on the ground. Cars randomly choose between two car models for variety.
        const obstacleDefs = {
            car: {
                factory: () => {
                    // randomly choose one of the two car models
                    const choice = Math.random() > 0.5 ? 'car01' : 'car02';
                    return preparedClone(choice);
                },
                props: { harmful: true, tall: false, y: 0.75 }
            },
            barrier: {
                factory: () => new THREE.Mesh(
                    new THREE.BoxGeometry(LANE_WIDTH, 2.5, 0.5),
                    new THREE.MeshStandardMaterial({ color: 0xffff00 })
                ),
                props: { harmful: true, tall: true, y: 1.25 }
            },
            police: {
                factory: () => preparedClone('police'),
                props: { harmful: true, tall: true, y: 1.0 }
            },
            scooter: {
                factory: () => preparedClone('scooter'),
                props: { harmful: true, tall: false, y: 0.5 }
            }
        };
        const collectibleTypes = {
            speed: { factory: () => new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.2, 8, 16), new THREE.MeshStandardMaterial({color: 0x00ff00})), type: 'speed', icon: '⚡', sound: 'collectSpeed'},
            invincibility: { factory: () => new THREE.Mesh(new THREE.OctahedronGeometry(0.7), new THREE.MeshStandardMaterial({color: 0xffff00, metalness: 0.5, roughness: 0.2})), type: 'invincibility', icon: '🛡️', sound: 'collectInvincibility'},
            life: { factory: () => new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshStandardMaterial({color: 0xff00ff, emissive: 0x550055})), type: 'life', icon: '❤️', sound: 'collectLife'},
        };
        
        function spawnObject() {
            const isObstacle = Math.random() > 0.3;
            const lane = Math.floor(Math.random() * 3) - 1;
            const zPos = -100;

            if (isObstacle) {
                // choose randomly among the keys of obstacleDefs: car, barrier, police, scooter
                const keys = Object.keys(obstacleDefs);
                const typeKey = keys[Math.floor(Math.random() * keys.length)];
                const def = obstacleDefs[typeKey];
                const obj = getFromPool(pools.obstacles, typeKey, def, activeObstacles);
                // use the specified y offset if provided, otherwise default to 1.0
                const yOffset = (def.props && typeof def.props.y === 'number') ? def.props.y : 1.0;
                obj.position.set(lane * LANE_WIDTH, yOffset, zPos);
            } else {
                const keys = Object.keys(collectibleTypes);
                const typeKey = keys[Math.floor(Math.random() * keys.length)];
                const obj = getFromPool(pools.collectibles, typeKey, collectibleTypes[typeKey], activeCollectibles);
                obj.position.set(lane * LANE_WIDTH, 1.5, zPos);
            }
        }
        
        function getFromPool(poolMap, typeKey, typeDef, targetPool) {
            if (!poolMap.has(typeKey)) poolMap.set(typeKey, []);
            let pool = poolMap.get(typeKey);
            let obj = pool.find(o => !o.visible);
            if (!obj) {
                obj = typeDef.factory();
                obj.castShadow = true;
                Object.assign(obj.userData, typeDef.props || { type: typeDef.type, icon: typeDef.icon, sound: typeDef.sound });
                pool.push(obj);
                scene.add(obj);
            }
            obj.visible = true;
            targetPool.push(obj);
            return obj;
        }


        // --- COLLISIONS & POWER-UPS ---
        function handleCollisions() {
            if (!player.mesh) return;
            player.collider.setFromObject(player.mesh).expandByScalar(-0.2); // Make hitbox slightly smaller
            
            for (const o of activeObstacles) {
                if (o.visible && o.userData.harmful) {
                    const obstacleCollider = new THREE.Box3().setFromObject(o);
                    if (player.collider.intersectsBox(obstacleCollider) && !player.isInvincible) {
                        triggerScreenShake(0.4, 0.4);
                        triggerParticles(player.mesh.position, 25, new THREE.Color(0xcc0000), 2);
                        playSound('hit', 0.6);
                        state.lives--;
                        updateLivesUI();
                        o.visible = false;
                        if (state.lives <= 0) { gameOver(); } 
                        else {
                            activatePowerUp('invincibility', 2);
                            handleVibrate(80);
                        }
                        return;
                    }
                }
            }
            
            for (const c of activeCollectibles) {
                if(c.visible && player.mesh.position.distanceTo(c.position) < 2) {
                    c.visible = false;
                    handleVibrate(40);
                    const collectibleDef = collectibleTypes[c.userData.type];
                    playSound(collectibleDef.sound, 0.4);
                    const tempMesh = collectibleDef.factory(); 
                    const color = tempMesh.material.color;
                    triggerParticles(c.position, 20, color, 1.5);
                    activatePowerUp(c.userData.type);
                }
            }
        }
        function activatePowerUp(type, duration = 8) {
            deactivatePowerUp(); // prevent stacking
            state.powerUp.type = type;
            state.powerUp.timer = duration;
            const powerUpDef = collectibleTypes[type];
            showToast(`${powerUpDef.icon} ${type.toUpperCase()}`);

            if (type === 'speed') {
                state.powerUp.originalSpeed = state.baseSpeed;
                state.baseSpeed *= 1.5;
            } else if (type === 'invincibility') {
                player.isInvincible = true;
                if (player.aura) player.aura.visible = true;
            } else if (type === 'life') {
                if(state.lives < 5) state.lives++;
                updateLivesUI();
                state.powerUp.timer = 0; // one-time effect
            }
        }
        function deactivatePowerUp() {
            const type = state.powerUp.type;
            if (!type) return;

            if (type === 'speed') {
                state.baseSpeed = state.powerUp.originalSpeed;
            } else if (type === 'invincibility') {
                player.isInvincible = false;
                if (player.aura) player.aura.visible = false;
            }
            state.powerUp = { type: null, timer: 0, originalSpeed: 0 };
        }
        
        function updateHUD() {
            ui.score.textContent = Math.floor(state.score);
            if (state.powerUp.type) {
                ui.powerupIcon.textContent = collectibleTypes[state.powerUp.type].icon;
                ui.powerupTimer.textContent = state.powerUp.timer.toFixed(1);
            } else {
                ui.powerupIcon.textContent = '';
                ui.powerupTimer.textContent = '';
            }
        }
        function updateLivesUI() {
            ui.livesDisplay.innerHTML = '';
            for(let i=0; i<state.lives; i++) {
                const lifeIcon = document.createElement('span');
                lifeIcon.textContent = '💜';
                ui.livesDisplay.appendChild(lifeIcon);
            }
        }
        function setupUI() {
            ui.startButton.addEventListener('click', startGame);
            ui.restartButton.addEventListener('click', () => {
                updateLeaderboard(ui.playerNameInput.value, Math.floor(state.score));
                startGame();
            });
            ui.pauseButton.addEventListener('click', togglePause);
            
            // Tabs
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    document.querySelectorAll('.panel-section').forEach(p => p.classList.remove('active'));
                    document.getElementById(targetId).classList.add('active');
                });
            });
            
            // Settings
            ui.acrobaticJumpsToggle.checked = settings.acrobaticJumps;
            ui.hapticsToggle.checked = settings.haptics;
            ui.reducedMotionToggle.checked = settings.reducedMotion;
            ui.soundToggle.checked = settings.audio;

            ui.acrobaticJumpsToggle.addEventListener('change', (e) => { settings.acrobaticJumps = e.target.checked; saveState(); });
            ui.hapticsToggle.addEventListener('change', (e) => { settings.haptics = e.target.checked; saveState(); });
            ui.reducedMotionToggle.addEventListener('change', (e) => { settings.reducedMotion = e.target.checked; saveState(); });
            ui.soundToggle.addEventListener('change', (e) => { 
                settings.audio = e.target.checked; 
                if (settings.audio && gameActive && !isPaused && audio.music && !audio.music.isPlaying) {
                    audio.music.play();
                } else if (!settings.audio && audio.music && audio.music.isPlaying) {
                    audio.music.pause();
                }
                saveState(); 
            });
            
            // Data
            ui.exportButton.addEventListener('click', exportData);
            ui.importInput.addEventListener('change', importData);

            updateUIFromState();
        }
        function updateUIFromState() {
             ui.acrobaticJumpsToggle.checked = settings.acrobaticJumps;
             ui.hapticsToggle.checked = settings.haptics;
             ui.reducedMotionToggle.checked = settings.reducedMotion;
             ui.soundToggle.checked = settings.audio;
             renderLeaderboard();
             renderSkins();
        }

        // --- GESTURES & CONTROLS ---
        function setupControls() {
            let touchState = { startX: 0, startY: 0, endX: 0, endY: 0, startTime: 0, isSwiping: false, lastSwipeTime: 0, lastSwipeDirection: '' };
            
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchState.startX = touch.clientX;
                touchState.startY = touch.clientY;
                touchState.startTime = performance.now();
                touchState.isSwiping = false;
            };

            const handleTouchMove = (e) => {
                 if (touchState.isSwiping) return;
                 const touch = e.touches[0];
                 const deltaX = touch.clientX - touchState.startX;
                 const deltaY = touch.clientY - touchState.startY;
                 if (Math.abs(deltaX) > 20 || Math.abs(deltaY) > 20) {
                     touchState.isSwiping = true;
                 }
            };
            
            const handleTouchEnd = (e) => {
                 const touch = e.changedTouches[0];
                 touchState.endX = touch.clientX;
                 touchState.endY = touch.clientY;
                 handleGesture(touchState);
            };

            gameContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
            gameContainer.addEventListener('touchmove', handleTouchMove, { passive: true });
            gameContainer.addEventListener('touchend', handleTouchEnd, { passive: true });

            window.addEventListener('keydown', (e) => {
                if(!gameActive || isPaused) return;
                switch(e.code) {
                    case 'ArrowLeft': case 'KeyA': move('left'); break;
                    case 'ArrowRight': case 'KeyD': move('right'); break;
                    case 'ArrowUp': case 'KeyW': case 'Space': jump(); break;
                    case 'ArrowDown': case 'KeyS': slide(); break;
                }
            });
        }

        function handleGesture(touchState) {
            if (!gameActive || isPaused) return;
            const deltaX = touchState.endX - touchState.startX;
            const deltaY = touchState.endY - touchState.startY;
            const duration = performance.now() - touchState.startTime;

            if (duration > 500) return; // Ignore long presses

            let direction = '';
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (Math.abs(deltaX) > 40) direction = deltaX > 0 ? 'right' : 'left';
            } else {
                if (Math.abs(deltaY) > 40) direction = deltaY > 0 ? 'down' : 'up';
            }
            
            if (direction === '') return;

            const now = performance.now();
            if (direction === 'up') {
                if (settings.acrobaticJumps && touchState.lastSwipeDirection === 'up' && (now - touchState.lastSwipeTime) < 300) {
                    frontFlip();
                    touchState.lastSwipeTime = 0; // Reset after double
                } else {
                    jump();
                    touchState.lastSwipeTime = now;
                }
            } else if (direction === 'down') {
                slide();
            } else {
                move(direction);
            }
            touchState.lastSwipeDirection = direction;
        }

        function move(direction) {
            if (direction === 'left' && player.lane > -1) player.lane--;
            if (direction === 'right' && player.lane < 1) player.lane++;
            player.targetX = player.lane * LANE_WIDTH;
        }
        function jump() {
            if (player.coyoteTimer > 0 && player.state !== 'flipping') {
                player.state = 'jumping';
                player.velocityY = player.jumpForce;
                player.coyoteTimer = 0;
                handleVibrate(30);
                playSound('jump', 0.4);
                if (player.animations.jumping) {
                    player.animations.jumping.stop().play();
                }
            }
        }
        function frontFlip() {
             if (player.coyoteTimer > 0 && player.state !== 'flipping' && player.flipCooldown <= 0) {
                player.state = 'flipping';
                player.velocityY = player.frontFlipForce;
                player.coyoteTimer = 0;
                handleVibrate([50, 30, 50]);
                playSound('flip', 0.5);
                if (player.animations.jumping) { // Use jumping animation for flip
                    player.animations.jumping.stop().play();
                }
            }
        }
        function addFlipScore() {
            const flipBonus = 500;
            state.score += flipBonus;
            ui.flipComboDisplay.textContent = `+${flipBonus} FLIP!`;
            ui.flipComboDisplay.classList.add('visible');
            setTimeout(() => ui.flipComboDisplay.classList.remove('visible'), 1000);
        }
        function slide() {
             if (player.state === 'running') {
                player.state = 'sliding';
                player.slideTimer = 0.5;
                handleVibrate(20);
                if (player.animations.sliding) {
                    player.animations.sliding.stop().play();
                }
            }
        }

        // --- SKINS, DATA, & UNLOCKS ---
        function renderSkins() {
            ui.skinsGrid.innerHTML = '';
            Object.keys(SKINS).forEach(id => {
                const skin = SKINS[id];
                const isUnlocked = settings.skins.unlocked.includes(id);
                const isActive = settings.skins.current === id;
                const button = document.createElement('button');
                button.className = `skin-button ${isActive ? 'active' : ''} ${!isUnlocked ? 'locked' : ''}`;
                button.title = `${skin.name}${!isUnlocked ? ` (Odemkne se za ${skin.unlock} bodů)` : ''}`;
                
                const preview = document.createElement('div');
                preview.className = 'skin-color-preview';
                preview.style.background = `#${new THREE.Color(skin.color).getHexString()}`;
                button.appendChild(preview);

                if (isUnlocked) {
                    button.addEventListener('click', () => {
                        settings.skins.current = id;
                        applySkin(id);
                        saveState();
                        renderSkins(); // Re-render to show active state
                    });
                }
                ui.skinsGrid.appendChild(button);
            });
        }
        function applySkin(id) {
            if (!SKINS[id] || !player.mesh) return;
            const skin = SKINS[id];
            
            player.mesh.traverse(child => {
                if (child.isMesh && child.material && child.material.color) {
                    // Apply skin color to any mesh part that has a color property
                    child.material.color.setHex(skin.color);
                }
            });
        }
        function checkUnlocks(score) {
            let unlockedNew = false;
            Object.keys(SKINS).forEach(id => {
                const skin = SKINS[id];
                if(skin.unlock && score >= skin.unlock && !settings.skins.unlocked.includes(id)) {
                    settings.skins.unlocked.push(id);
                    showToast(`Nový skin odemčen: ${skin.name}!`);
                    unlockedNew = true;
                }
            });
            if (unlockedNew) saveState();
        }
        function renderLeaderboard() {
             ui.leaderboardList.innerHTML = '';
             settings.leaderboard.sort((a,b) => b.score - a.score).slice(0, 5).forEach((entry, index) => {
                 const li = document.createElement('li');
                 li.innerHTML = `<span>#${index+1} ${entry.name}</span><span>${entry.score}</span>`;
                 ui.leaderboardList.appendChild(li);
             });
        }
        function updateLeaderboard(name, score) {
            if (!name || score <= 0) return;
            name = name.substring(0, 15);
            settings.leaderboard.push({name, score});
            checkUnlocks(score);
            saveState();
            renderLeaderboard();
        }
        
        // --- DATA MANAGEMENT & HELPERS ---
        function exportData() {
            const dataStr = JSON.stringify(settings);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportFileDefaultName = 'fofr-pedro-save.json';
            let linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedSettings = JSON.parse(e.target.result);
                    // Simple validation
                    if (importedSettings.leaderboard && importedSettings.skins) {
                         settings = deepMerge(settings, importedSettings);
                         saveState();
                         updateUIFromState();
                         showToast('Data úspěšně importována!');
                    } else { throw new Error('Invalid save file structure.'); }
                } catch(err) {
                    showToast(`Chyba při importu: ${err.message}`);
                }
            };
            reader.readAsText(file);
        }
        function loadState() {
            try {
                const saved = localStorage.getItem(SAVE_KEY);
                if (saved) {
                    settings = deepMerge(settings, JSON.parse(saved));
                }
            } catch (e) { console.error('Failed to load state from localStorage', e); }
        }
        function saveState() {
            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(settings));
            } catch (e) { console.error('Failed to save state to localStorage', e); }
        }
        function handleVibrate(pattern) {
            if (settings.haptics && navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.className = 'toast glass-panel';
            ui.toastContainer.appendChild(toast);
            setTimeout(() => { toast.classList.add('show'); }, 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }
        function deepMerge(target, source) {
            for (const key in source) {
                if (source[key] instanceof Object && key in target) {
                    Object.assign(source[key], deepMerge(target[key], source[key]));
                }
            }
            Object.assign(target || {}, source);
            return target;
        }

        function updateDebugOverlay(delta) {
             const fps = (1 / delta).toFixed(0);
             ui.debugOverlay.textContent = `FPS: ${fps}\nSpeed: ${state.speed.toFixed(1)}\nState: ${player.state}\nLane: ${player.lane}\nInvincible: ${player.isInvincible}`;
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- GO! ---
        init();
    </script>
        <script>
            // Register the service worker.  This script is added at the end of the body to ensure
            // all resources are loaded before attempting registration.  It mirrors the
            // recommended registration pattern【671841202824234†L224-L243】.
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js')
                        .then(reg => console.log('[SW] Registered', reg.scope))
                        .catch(err => console.error('[SW] Registration failed', err));
                });
            }
        </script>
    </body>
</html>